|설명|용어|
|---|---|
|각 단계를 확실히 매듭짓고 결과를 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론|폭포수 모형|
|실제 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물을 예측하는 모형|프로토타입 모형|
|여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 개발하는 모형, 보헴이 제안하였다.|나선형 모형|
|나선형 모형의 4가지 주요 활동|계획수립->위험분석->개발 및 검증->고객평가(계위개고)|
|요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형, 폭포수 모형과 대조적이다.|애자일 모형|
|애자일 모형의 개발 모형|스크럼, XP, 칸반, Lean, 기능중심개발|
|소프트웨어의 위기를 극복 하기 위한 방안으로 연구된 학문|소프트웨어 공학|
|팀이 중심이 되어 개발의 효율성을 높이는 기법|스크럼|
|스크럼 팀의 구성원중 요구사항이 담긴 백로그를 작성하는 주체이고, 이해관계자들 중 개발될 제품에 대한 이해도가 높고, 의사를 결정할 수 있는 사람|제품 책임자(PO)|
|스크럼 팀이 스크럼을 잘 수행할 수 있도록 가이드 역할을 수행하는 사람|스크럼 마스터(SM)|
|제품 책임자와 스크럼 마스터를 제외한 모든 팀원|개발팀(DT)|
|스크럼 개발 프로세스를 작성하시오.|스프린트 계획 회의 -> 스프린트 -> 일일 스크럼 회의 -> 스프린트 검토회의 -> 스프린트 회고|
|요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상시키는 방법, 릴리즈의 기간을 짧게 반복|XP|
|XP의 5가지 핵심가치|의사소통, 단순성, 용기, 존중, 피드백(의단용준피)|
|XP 개발 프로세스|릴리즈 계획 수립-> 이터레이션->승인 검사->소규모 릴리즈|
|다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성하는 것|짝(페어) 프로그래밍|
|개발 코드에 대한 권한과 책임을 공동으로 소유하는 것|공동 코드 소유|
|개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지를 정확히 파악하는 것|테스트 주도 개발(TDD)|
|개발에 참여하는 모든 구성원들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 함.|전체 팀|
|모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리 될 때마다 지속적으로 통합되는 것|계속적인 통합|
|프로그램 기능의 변경 없이 시스템을 재구성하는 것, 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하기 위함|리팩토링|
|릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있음|소규모 릴리즈|
|컴퓨터 시스템의 자원을 효율적으로 관리하며, 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어|운영체제|
|운영체제 관련 요구사항 식별 시 고려사항|가용성, 성능, 기술 지원, 주변 기기, 구축 비용(가성기주구)
|사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고, 데이터베이스를 관리해 주는 소프트웨어|DBMS|
|DBMS 관련 요구사항 식별 시 고려사항|가용성, 성능, 기술 지원, 상호 호환성, 구축 비용(가성기상구)|
|사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어|웹 애플리케이션 서버(WAS)|
|웹 애플리케이션 서버 관련 요구사항 식별 시 고려사항|가용성, 성능, 기술 지원, 구축 비용(가성기구)
|누구나 별다른 제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어|오픈 소스|
|오픈 소스 관련 요구사항 식별 시 고려사항|라이선스의 종류, 사용자 수, 기술의 지속 가능성|
|소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건|요구사항|
|시스템이 무엇을 하는지, 어떤 기능을 하는지 등의 기능이나 수행과 관련된 요구사항, 시스템이 반드시 수행해야 하는 기능|기능 요구사항|
|품질이나 제약사항과 관련된 요구사항, 성능 요구사항, 인터페이스 요구사항 등등|비기능 요구사항|
|품질 요구사항의 종류|가용성, 정합성, 상호 호환성, 대응성, 이식성, 확장성, 보안성(가정상대이확보)
|사용자 관점에서 본 시스템이 제공해야 할 요구사항|사용자 요구사항|
|개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에게 제공해야 할 요구사항, 전문적이고 기술적인 용어로 표현 된다.|시스템 요구사항|
|요구사항을 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 활동|요구사항 개발 프로세스|
|요구사항 개발 프로세스 순서|도출->분석->명세->확인(도분명확)|
|시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 식별하고 이해하는 과정|요구사항 도출|
|요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정|요구사항 분석|
|분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것|요구사항 명세|
|요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동|요구사항 확인|
|무엇을 개발해야 하는지 요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문, 소프트웨어 프로젝트 실패를 최소화하는 것이 목표|요구공학|
|요구사항 명세 기법중에 하나로 요구사항을 정확하고 간결하게 표현할 수 있고, 수학적 기호와 정형화된 표기법을 사용한다.|정형 명세 기법|
|일반 명사, 동사 등의 자연어를 기반으로 서술하거나 다이어그램으로 작성하고, 자연어의 사용으로 인해 일관성이 떨어지지만, 의사소통이 용이하다.|비정형 명세 기법|
|자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법, 도형 중심의 분석용 도구와 분석 절차를 이용|구조적 분석 기법|
|요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법, 자료흐름 그래프, 버블 차트라고도 한다.|자료 흐름도|
|자료 흐름도의 기본 기호중에 하나로 자료를 변환시키는 시스템의 한 부분 처리, 기능, 변환, 버블이라고도 함|프로세스|
|자료 흐름도의 기본 기호중에 하나로 자료의 이동이나 연관관계를 나타냄|자료의 흐름|
|자료 흐름도의 기본 기호중에 하나로 시스템에서의 자료 저장소를 나타냄|자료 저장소|
|자료 흐름도의 기본 기호중에 하나로 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받음|단말|
|자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것이다.|자료사전(DD)|
|자료 사전에서 사용되는 표기 기호로 ~로 구성되어 있다 라는 뜻을 담고 있는 기호와 그 의미는?|=, 자료의 정의|
|자료 사전에서 사용되는 표기 기호로 그리고 라는 뜻을 담고 있는 기호와 그 의미는?|+, 자료의 연결|
|자료 사전에서 사용되는 표기 기호로 또는 이라는 뜻을 담고 있는 기호와 그 의미는?|[], 자료의 선택|
|자료 사전에서 사용되는 표기 기호로 반복 이라는 뜻을 담고 있는 기호와 그 의미는?|{}, 자료의 반복|
|자료 사전에서 사용되는 표기 기호로 주석 이라는 뜻을 담고 있는 기호와 그 의미는?|* *, 자료의 설명|
|자료 사전에서 사용되는 표기 기호로 생략 가능한 자료 라는 뜻을 담고 있는 기호와 그 의미는?|(), 자료의 생략|
|요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구|요구사항 분석용 CASE|
|요구사항 분석용 CASE의 종류중 하나로 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위한 도구이다. SoftTech사에서 개발했다.|SADT|
|시스템 실행 과정인 입력, 처리, 출력의 기능을 표현한 것이고, 하향식 소프트웨어 개발을 위한 문서화 도구이다. 기호, 도표등을 사용하므로 보기 쉽다.|HIPO|
|시스템 분석, 설계, 구현 등 시스템 개발 과정에서 고객 또는 개발자 상호 간의 의사소통이 이루어지도록 표준화한 대표적인 객체지향 모델링 언어|UML|
|UML의 구성요소 3가지|사물, 관계, 다이어그램(사관다)|
|다이어그램 안에서 관계가 형성될 수 있는 대상들|사물|
|사물의 종류 4가지|구조 사물, 행동 사물, 그룹 사물, 주해 사물|
|UML의 사물의 종류 중 시스템의 개념적, 물리적 요소를 표현하는 것|구조 사물|
|UML의 사물의 종류 중 시간과 공간에 따른 요소들의 행위를 표현하는 것|행동 사물|
|UML의 사물의 종류 중 요소들을 그룹으로 묶어서 표현 하는 것|그룹 사물|
|UML의 사물의 종류 중 부가적인 설명이나 제약조건 등을 표현하는 것|주해 사물|
|사물과 사물 사이의 연관성을 표현하는 것|관계|
|UML의 관계의 종류 6가지|연관, 집합, 포함, 일반화, 의존, 실체화 관계|
|2개 이상의 사물이 서로 관련되어 있는 관계, 사물 사이를 실선으로 연결하여 표현한다.|연관 관계|
|하나의 사물이 다른 사물에 포함되어 있는 관계, 부분에서 전체로 속이 빈 마름모 실선을 이용하여 연결한다.|집합 관계|
|포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계, 부분에서 전체로 속이 꽉찬 마름모 실선을 이용하여 연결한다.|포함 관계|
|하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계|일반화 관계|
|필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계|의존 관계|
|사물이 할 수 있거나 해야하는 기능으로, 서로를 그룹화 할 수 있는 관계|실체화 관계|
|사물과 관계를 도형으로 표현한 것|다이어그램|
|클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현하는 것, 정적모델링에 속한다.|클래스 다이어그램|
|클래스에 속한 사물들, 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현, 럼바우 객체지향 분석 기법에서 객체 모델링에 활용|객체 다이어그램|
|실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현|컴포넌트 다이어그램|
|결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현|배치 다이어그램|
|클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현|복합체 구조 다이어그램|
|유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현|패키지 다이어그램|
|구조적 다이어그램의 종류 6가지|클래스, 객체, 컴포넌트, 배치, 복합체 구조, 패키지 다이어그램(클객컴배복패)|
|사용자의 요구를 분석하는 것으로, 기능 모델링 작업에 사용, 사용자와 사용 사례로 구성,개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현|유스케이스 다이어그램|
|상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현|시퀀스 다이어그램|
|동작에 참여하는 객체들이 주고받는 메시지와 객체들 간의 연관 관계를 표현|커뮤니케이션 다이어그램|
|하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현, 럼바우 객체지향에서 동적 모델링 활용|커뮤니케이션 다이어그램|
|시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현|활동 다이어그램|
|상호작용 다이어그램 간의 제어 흐름을 표현|상호작용 다이어그램|
|객체 상태 변화와 시간 제약을 명시적으로 표현|타이밍 다이어그램|
|행위 다이어그램의 종류 7가지|유스케이스, 시퀀스, 커뮤니케이션, 상태, 활동, 상호작용,
타이밍 다이어그램(유시커상활상타)|
|UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하는 것, 그리고 그 표현 형태|스테레오 타입|
|개발될 시스템이 갖춰야 할 기능을 사용자와 공유하기 위해 그림으로 표현하는 것|기능 모델링|
|기능 모델링의 종류 2가지|유스케이스 다이어그램, 액티비티(활동) 다이어그램|
|활동 다이어그램에서 액티비티 수행을 담당하는 주체를 구분하는 선의 명칭|스윔 레인|
|사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것, 객체들을 클래스로 추상화하여 표현한다.|정적 모델링|
|연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스|연관 클래스|
|시스템의 내부 구성 요소들의 상태 변화 과정과 그 과정에서 발생하는 상호 작용을 표현한 것|동적 모델링|
|동적 모델링의 종류 3가지|시퀀스, 커뮤니케이션, 상태 다이어그램|
|시퀀스 다이어그램의 구성요소 중 하나로 객체가 메모리에 존재하는 기간을 점선을 그어 표시하는 것|생명선|
|시퀀스 다이어그램의 구성요소 중에 하나로 객체가 메시지를 주고받으며 구동되고 있음을 표현하는 것|실행 상자|
|시퀀스 다이어그램의 구성요소 중에 하나로 객체가 상호 작용을 위해 주고 받는 메세지를 표현하는 것|메시지|
|소프트웨어 개발, 유지보수 등에 필요한 수행 방법과 효율적으로 수행하려는 과정에서 필요한 각종 기법 및 도구를 체계적으로 정리하여 표준화 한 것|소프트웨어 개발 방법론|
|소프트웨어 개발 방법론 6가지|구조적, 정보공학, 객체지향, 컴포넌트 기반, 제품 계열, 애자일 방법론|
|사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론, 1960년대까지 가장 많이 적용되었던 방법론이다.|구조적 방법론|
|구조적 방법론의 개발 절차|타당성 검토->계획->요구사항->설계->구현->시험->유지보수(타계요설구시유)|
|정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 통합 및 적용하는 자료 중심의 방법론|정보공학 방법론|
|정보공학 방법론의 개발 절차|정보 전략 계획 수립->업무 영역 분석->업무 시스템 설계->업무 시스템 구축|
|객체들을 조립해서 소프트웨어를 구현하는 방법론|객체지향 방법|
|객체지향 방법론의 구성 요소 3가지|객체, 클래스, 메시지|
|객체지향 방법론의 특징 4가지|캡슐화, 추상화 ,상속성, 다형성|
|객체지향 방법론의 기본 원칙 5가지|단일 책임 원칙(Single responsibility principle) : SRP, 개방 폐쇄 원칙(Open/closed principle) : OCP, 리스코프 치환 원칙(Liskov substitution principle) : LSP, 인터페이스 분리 원칙(Interface segregation principle) : ISP, 의존관계 역전 원칙(Dependency inversion principle) : DIP|
|객체지향 방법론의 개발 절차|요구 분석->설계->구현->테스트 및 검증->인도|
|컴포넌트를 조합하여 새로운 애플리케이션을 만드는 방법론, 컴포넌트의 재사용이 가능하여 시간과 노력을 절감할 수 있다.|컴포넌트 기반 방법론|
|컴포넌트 기반 방법론의 개발 절차|개발 준비->분석->설계->구현->테스트->전개->인도|
|제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론|제품 계열 방법론|
|이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것|소프트웨어 재사용|
|소프트웨어 재사용 방법 중 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법|합성 중심|
|소프트웨어 재사용 방법 중 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법|생성 중심|
|기존 시스템을 이용하여 보다 나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것|소프트웨어 재공학|
|소프트웨어 재공학의 이점 4가지|품질 향상, 생산성 증가, 수명 연장, 오류 감소|
|소프트웨어 개발 과정에서 사용되는 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것|CASE|
|과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 방법|하향식 비용 산정 기법|
|하향식 비용 산정 기법의 종류 2가지|전문가 감정 기법, 델파이 기법|
|경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법|전문가 감정 기법|
|전문가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가의 의견을 종합하여 산정하는 기법|델파이 기법|
|세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법|상향식 비용 산정 기법|
|각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법|LOC 기법|
|예측치 공식|a+4m+b/6, a=낙관치, b=비관치, m=기대치|
|LOC기법의 산정 공식 1) 노력, 2) 개발 비용, 3) 개발 기간, 4) 생산성|1) 노력 : 개발기간 * 투입인원 = LOC/ 1인당 월평균 생산 라인수 2) 개발비용 : 노력 * 단위 비용, 3) 개발 기간 : 노력 / 투입 인원|
|기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정하는 것, LOC 기법을 보강|개발 단계별 인원수 기법|
|수학적 산정 기법의 종류 3가지|COCOMO모형, Putnam모형, FP모형|
|LOC에 의한 비용 산정 기법, 소프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 산정, 보헴이 제안하였다.|COCOMO 모형|
|COCOMO의 소프트웨어 개발 유형 3가지|조직형, 반분리형, 내장형|
|COCOMO의 소프트웨어 개발 유형 중에 하나로 기관 내부에서 개발된 중, 소 규모의 소프트웨어이고 5만 라인 이하의 소프트웨어를 개발한다.|조직형|
|COCOMO의 소프트웨어 개발 유형 중에 하나로 조직형과 내장형의 중간형 소프트웨어이고 30만 라인 이하의 소프트웨어를 개발한다.|반분리형|
|COCOMO의 소프트웨어 개발 유형 중에 하나로 초대형 규모의 소프트웨어이고 30만 라인 이상의 소프트웨어를 개발한다.|내장형|
|소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형이다. 푸트남이 제안하였고, 생명 주기 예측 모형이라고도 한다.|Putnam 모형|
|소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여하여 기능 점수를 구한 후 비용을 산정하는 기법|기능점수(FP)모형|
|Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구|SLIM|
|다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발된 자동화 추정 도구|ESTIMACS|
|프로젝트 일정 계획 중 전체 작업의 상호 관계를 표시하는 네트워크|PERT|
|프로젝트 일정 계획 중 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법|CPM|
|프로젝트의 작업 일정을 막대 도표를 이용하여 표시하는 프로젝트 일정표|간트 차트|
|소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준|소프트웨어 개발 표준|
|ISO에서 만든 표준 소프트웨어 생명 주기 프로세스|ISO/IEC 12207|
|기본 생명 주기 프로세스의 종류|획득, 공급, 개발, 운영, 유지보수 프로세스|
|지원 생명 주기 프로세스의 종류|품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상 관리, 문제 해결|
|조직 생명 주기 프로세스의 종류|관리, 기반 구조, 훈련, 개선 프로세스|
|소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델|CMMI|
|CMMI의 소프트웨어 프로세스 성숙도 단계|초기, 관리, 정의, 정량적관리, 최적화|
|소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준|SPICE|
|SPICE의 구성 5가지|고객-공급자, 공학, 지원, 관리, 조직|
|SPICE의 프로세스 수행 능력 단계|불완전, 수행, 관리, 확립, 예측, 최적화|
|소프트웨어 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업|소프트웨어 개발 방법론 테일러링|
|소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 제공해주는 반제품 형태의 소프트웨어 시스템|소프트웨어 개발 프레임워크|
|자바 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크이고, 전자정부 표준 프레임워크의 기반 기술로 사용되고 있다.|스프링 프레임워크|
|대한민국의 공공부문 정보화 사업 시 정보시스템의 구축을 지원하기 위해 필요한 기능 및 아키텍처를 제공하는 프레임워크|전자정부 프레임워크|
|Windows의 프로그램의 개발 및 실행 환경을 제공하는 프레임 워크|닷넷 프레임워크|
|소프트웨어 개발 프레임워크의 특성 4가지|모듈화, 재사용성, 확장성, 제어의 역흐름|
|캡슐화를 통해 모듈화를 강화하고 설계 및 구현이 변경에 따른 영향을 최소화함으로써 소프트웨어의 품질을 향상시키는 것|모듈화|
|재사용 가능한 모듈들을 제공함으로써 예산 절감, 생산성 향상, 품질 보증이 가능함|재사용성|
|다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능|확장성|
|개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생산성을 향상시킴|제어의 역흐름|
|공동으로 사용될 데이터를 중복을 배제하여 통합하고, 쉽게 접근하여 처리할 수 있도록 저장장치에 저장하여 항상 사용할 수 있도록 운영하는 운영 데이터|데이터베이스|
|데이터베이스의 정의 4가지|통합된 데이터, 저장된 데이터, 운영 데이터, 공용 데이터|
|자료의 중복을 배제한 데이터의 모임|통합된 데이터|
|컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료|저장된 데이터|
|조직의 고유한 업무를 수행하는 데 반드시 필요한 자료|운영 데이터|
|여러 응용 시스템들이 공동으로 소유하고 유지하는 자료|공용 데이터|
|사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어, 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성을 해결하기 위해 제안된 소프트웨어|DBMS|
|DBMS의 필수 기능 3가지|정의 기능, 조작 기능, 제어 기능|
|응용 프로그램과 데이터베이스를 독립시킴으로써, 데이터의 논리적 구조를 변경시키더라도 응용 프로그램은 영향을 받지 않음을 의미하는 것|논리적 독립성|
|응용 프로그램과 보조기억장치 같은 물리적 장치를 독립시킴으로써, 디스크를 추가/변경하더라도 응용 프로그램은 영향을 받지 않는 것|물리적 독립성|
|데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것|스키마|
|스키마의 종류 3가지|외부 스키마, 개념 스키마, 내부 스키마|
|사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것|외부 스키마|
|데이터베이스의 전체적인 논리적 구조, 모든 응용프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스|개념 스키마|
|물리적 저장장치의 입장에서 본 데이터베이스 구조, 실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법 등을 나타냄|내부 스키마|
|데이터베이스 설계 시 고려사항 6가지|무결성, 일관성, 회복, 보안, 효율성, 데이터베이스 확장|
|삽입, 삭제, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만족해야 함|무결성|
|데이터베이스에 저장된 데이터들 사이나, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 함|일관성|
|시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 함|회복|
|불법적인 데이터의 노출 또는 변경이나 손실로부터 보호할 수 있어야 함|보안|
|응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 함|효율성|
|데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 함|데이터베이스 확장|
|데이터베이스 설계 순서|요구조건 분석->개념적 설계->논리적 설계->물리적 설계->구현|
|데이터베이스를 사용할 사람들로부터 필요한 용도를 파악하는 것|요구 조건 분석|
|현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정|개념적 설계|
|현실 세계에서 발생하는 자료를 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정|논리적 설계|
|논리적 구조로 표현된 데이터를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정|물리적 설계|
|논리적 설계와 물리적 설계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정|데이터베이스 구현|
|현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형|데이터 모델|
|데이터 모델의 구성 요소 3가지|개체, 속성, 관계|
|데이터 모델에 표시할 요소 3가지|구조, 연산, 제약 조건|
|현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정|개념적 데이터 모델|
|개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정|논리적 데이터 모델|
|논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현|구조|
|데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구|연산|
|데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건|제약 조건|
|데이터베이스에 표현하려는 것, 개념이나 정보단위 같은 현실 세계의 대상체|개체|
|데이터베이스를 구성하는 가장 작은 논리적 단위|속성|
|속성의 수|디그리, 차수|
|업무 분석을 통해 정의한 속성, 속성 중 가장 많고 일반적임|기본 속성|
|원래 업무상 존재하지 않고 설계 과정에서 도출해내는 속성|설계 속성|
|다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성|파생 속성|
|개체와 개체 사이의 논리적인 연결|관계|
|두 개체 사이의 주 종 관계를 표현한 것|종속 관계|
|두 개체 사이에 2번 이상의 종속 관계가 발생하는 관계|중복 관계|
|개체가 자기 자신과 관계를 갖는 것|재귀 관계|
|개체의 속성이나 구분자를 기준으로 개체의 특성을 분할하는 관계|배타 관계|
|E-R 다이어그램의 기호중 사각형 인것|개체|
|E-R 다이어그램의 기호중 마름모 인 것|관계|
|E-R 다이어그램의 기호 중 타원 인 것|속성|
|E-R 다이어그램의 기호 중 이중타원 인 것|다중값 속성|
|E-R 다이어그램의 기호 중 밑줄 타원 인 것|기본키 속성|
|E-R 다이어그램의 기호 중 복수타원인 것|복합 속성|
|2차원적인 표를 이용해서 데이터 상호 관계를 정의하는 데이터베이스|관계형 데이터베이스|
|릴레이션을 구성하는 각각의 행|튜플|
|하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값의 집합|도메인|
|릴레이션의 특징 3가지|릴레이션에 포함된 튜플은 모두 상이하다, 튜플 사이에는 순서가 없다, 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.|
|2차원적인 표를 이용해서 데이터 상호 관계를 정의하는 DB 구조|관계형 데이터 모델|
|속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합|후보키|
|후보키의 속성 2가지|유일성, 최소성|
|하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함|유일성|
|키를 구성하는 속성 하나를 제거하면 유일하게 식별할 수 없도록 꼭 필요한 최소의 속성으로 구성되어야 함.|최소성|
|후보키 중에서 특별히 선정된 주키이다, 중복된 값을 가질 수 없고 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다.|기본키|
|후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키|대체키|
|한 릴레이션 내에 있는 속성들의 집합으로 구성된 키, 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못한다.|슈퍼키|
|다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합|외래키|
|데이터베이스에 저장된 데이터 값과 현실 세계의 실제값이 일치하는 정확성|무결성|
|기본 테이블의 기본키를 구성하는 어떤 속성도 NULL 값이나 중복값을 가질 수 없다는 규정|개체 무결성|
|외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정|참조 무결성|
|주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정|도메인 무결성|
|속성 값들이 사용자가 정의한 제약조건에 만족되어야 한다는 규정|사용자 정의 무결성|
|릴레이션의 특정 속성 값이 NULL이 될 수 없도록 하는 규정|NULL 무결성|
|릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 한다는 규정|고유 무결성|
|하나의 릴레이션에는 적어도 하나의 키가 존재해야 한다는 규정|키 무결성|
|한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정|관계 무결성|
|원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어|관계대수|
|순수 관계 연산자의 종류 4가지|Select, Project, Join, Division|
|일반 집합 연산자의 종류 4가지|합집합, 교집합, 차집합, 교차곱|
|관계 데이터의 연산을 표현하는 방법|관계해석|
|릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산의 종류와 그 기호|Select|
|주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산, 중복이 발생하면 중복이 제거되는 종류와 그 기호|Project|
|공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산의 종류와 그 기호|Join|
|R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산|Division|
|두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제거되는 연산|합집합|
|두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산|교집합|
|두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산|차집합|
|두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산|교차곱|
|테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이 중복으로 인해 테이블 조작 시 문제가 발생하는 현상|이상|
|테이블에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상|삽입 이상|
|테이블에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상|삭제 이상|
|테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상|갱신 이상|
|속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을 때를 의미하는 것, 또 X->Y 일 때 X, Y는?|함수적 종속|
|테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정|정규화|
|테이블 R에 속한 모든 속성의 도메인이 원자 값만으로 되어 있는 정규형, 즉 테이블의 모든 속성값이 원자 값으로만 되어 있는 정규형|제 1정규형|
|기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형|제 2정규형|
|기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않는 정규형|제 3정규형|
|모든 결정자가 후보키인 정규형|BCNF|
