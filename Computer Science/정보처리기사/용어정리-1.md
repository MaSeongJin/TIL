|설명|용어|
|---|---|
|각 단계를 확실히 매듭짓고 결과를 검토하여 승인 과정을 거친 후에 다음 단계를 진행하는 개발 방법론|폭포수 모형|
|실제 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물을 예측하는 모형|프로토타입 모형|
|여러 번의 소프트웨어 개발 과정을 거쳐 점진적으로 개발하는 모형, 보헴이 제안하였다.|나선형 모형|
|나선형 모형의 4가지 주요 활동|계획수립->위험분석->개발 및 검증->고객평가(계위개고)|
|요구사항 변화에 유연하게 대응할 수 있도록 일정한 주기를 반복하면서 개발하는 모형, 폭포수 모형과 대조적이다.|애자일 모형|
|애자일 모형의 개발 모형|스크럼, XP, 칸반, Lean, 기능중심개발|
|소프트웨어의 위기를 극복 하기 위한 방안으로 연구된 학문|소프트웨어 공학|
|팀이 중심이 되어 개발의 효율성을 높이는 기법|스크럼|
|스크럼 팀의 구성원중 요구사항이 담긴 백로그를 작성하는 주체이고, 이해관계자들 중 개발될 제품에 대한 이해도가 높고, 의사를 결정할 수 있는 사람|제품 책임자(PO)|
|스크럼 팀이 스크럼을 잘 수행할 수 있도록 가이드 역할을 수행하는 사람|스크럼 마스터(SM)|
|제품 책임자와 스크럼 마스터를 제외한 모든 팀원|개발팀(DT)|
|스크럼 개발 프로세스를 작성하시오.|스프린트 계획 회의 -> 스프린트 -> 일일 스크럼 회의 -> 스프린트 검토회의 -> 스프린트 회고|
|요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 생산성을 향상시키는 방법, 릴리즈의 기간을 짧게 반복|XP|
|XP의 5가지 핵심가치|의사소통, 단순성, 용기, 존중, 피드백(의단용준피)|
|XP 개발 프로세스|릴리즈 계획 수립-> 이터레이션->승인 검사->소규모 릴리즈|
|다른 사람과 함께 프로그래밍을 수행함으로써 개발에 대한 책임을 공동으로 나눠 갖는 환경을 조성하는 것|짝(페어) 프로그래밍|
|개발 코드에 대한 권한과 책임을 공동으로 소유하는 것|공동 코드 소유|
|개발자가 실제 코드를 작성하기 전에 테스트 케이스를 먼저 작성하므로 자신이 무엇을 해야할지를 정확히 파악하는 것|테스트 주도 개발(TDD)|
|개발에 참여하는 모든 구성원들은 각자 자신의 역할이 있고 그 역할에 대한 책임을 가져야 함.|전체 팀|
|모듈 단위로 나눠서 개발된 코드들은 하나의 작업이 마무리 될 때마다 지속적으로 통합되는 것|계속적인 통합|
|프로그램 기능의 변경 없이 시스템을 재구성하는 것, 프로그램을 쉽게 이해하고 쉽게 수정하여 빠르게 개발할 수 있도록 하기 위함|리팩토링|
|릴리즈 기간을 짧게 반복함으로써 고객의 요구 변화에 신속히 대응할 수 있음|소규모 릴리즈|
|컴퓨터 시스템의 자원을 효율적으로 관리하며, 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 환경을 제공하는 소프트웨어|운영체제|
|운영체제 관련 요구사항 식별 시 고려사항|가용성, 성능, 기술 지원, 주변 기기, 구축 비용(가성기주구)
|사용자와 데이터베이스 사이에서 사용자의 요구에 따라 정보를 생성해 주고, 데이터베이스를 관리해 주는 소프트웨어|DBMS|
|DBMS 관련 요구사항 식별 시 고려사항|가용성, 성능, 기술 지원, 상호 호환성, 구축 비용(가성기상구)|
|사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위해 사용되는 미들웨어|웹 애플리케이션 서버(WAS)|
|웹 애플리케이션 서버 관련 요구사항 식별 시 고려사항|가용성, 성능, 기술 지원, 구축 비용(가성기구)
|누구나 별다른 제한 없이 사용할 수 있도록 소스 코드를 공개한 소프트웨어|오픈 소스|
|오픈 소스 관련 요구사항 식별 시 고려사항|라이선스의 종류, 사용자 수, 기술의 지속 가능성|
|소프트웨어가 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명과 정상적으로 운영되는데 필요한 제약조건|요구사항|
|시스템이 무엇을 하는지, 어떤 기능을 하는지 등의 기능이나 수행과 관련된 요구사항, 시스템이 반드시 수행해야 하는 기능|기능 요구사항|
|품질이나 제약사항과 관련된 요구사항, 성능 요구사항, 인터페이스 요구사항 등등|비기능 요구사항|
|품질 요구사항의 종류|가용성, 정합성, 상호 호환성, 대응성, 이식성, 확장성, 보안성(가정상대이확보)
|사용자 관점에서 본 시스템이 제공해야 할 요구사항|사용자 요구사항|
|개발자 관점에서 본 시스템 전체가 사용자와 다른 시스템에게 제공해야 할 요구사항, 전문적이고 기술적인 용어로 표현 된다.|시스템 요구사항|
|요구사항을 도출하고 분석한 후 명세서에 정리한 다음 확인 및 검증하는 활동|요구사항 개발 프로세스|
|요구사항 개발 프로세스 순서|도출->분석->명세->확인(도분명확)|
|시스템 개발에 관련된 사람들이 서로 의견을 교환하여 요구사항을 식별하고 이해하는 과정|요구사항 도출|
|요구사항 중 명확하지 않거나 모호하여 이해되지 않는 부분을 발견하고 이를 걸러내기 위한 과정|요구사항 분석|
|분석된 요구사항을 바탕으로 모델을 작성하고 문서화하는 것|요구사항 명세|
|요구사항 명세서가 정확하고 완전하게 작성되었는지를 검토하는 활동|요구사항 확인|
|무엇을 개발해야 하는지 요구사항을 정의하고, 분석 및 관리하는 프로세스를 연구하는 학문, 소프트웨어 프로젝트 실패를 최소화하는 것이 목표|요구공학|
|요구사항 명세 기법중에 하나로 요구사항을 정확하고 간결하게 표현할 수 있고, 수학적 기호와 정형화된 표기법을 사용한다.|정형 명세 기법|
|일반 명사, 동사 등의 자연어를 기반으로 서술하거나 다이어그램으로 작성하고, 자연어의 사용으로 인해 일관성이 떨어지지만, 의사소통이 용이하다.|비정형 명세 기법|
|자료의 흐름과 처리를 중심으로 하는 요구사항 분석 방법, 도형 중심의 분석용 도구와 분석 절차를 이용|구조적 분석 기법|
|요구사항 분석에서 자료의 흐름 및 변환 과정과 기능을 도형 중심으로 기술하는 방법, 자료흐름 그래프, 버블 차트라고도 한다.|자료 흐름도|
|자료 흐름도의 기본 기호중에 하나로 자료를 변환시키는 시스템의 한 부분 처리, 기능, 변환, 버블이라고도 함|프로세스|
|자료 흐름도의 기본 기호중에 하나로 자료의 이동이나 연관관계를 나타냄|자료의 흐름|
|자료 흐름도의 기본 기호중에 하나로 시스템에서의 자료 저장소를 나타냄|자료 저장소|
|자료 흐름도의 기본 기호중에 하나로 시스템과 교신하는 외부 개체로, 입력 데이터가 만들어지고 출력 데이터를 받음|단말|
|자료 흐름도에 있는 자료를 더 자세히 정의하고 기록한 것이다.|자료사전(DD)|
|자료 사전에서 사용되는 표기 기호로 ~로 구성되어 있다 라는 뜻을 담고 있는 기호와 그 의미는?|=, 자료의 정의|
|자료 사전에서 사용되는 표기 기호로 그리고 라는 뜻을 담고 있는 기호와 그 의미는?|+, 자료의 연결|
|자료 사전에서 사용되는 표기 기호로 또는 이라는 뜻을 담고 있는 기호와 그 의미는?|[], 자료의 선택|
|자료 사전에서 사용되는 표기 기호로 반복 이라는 뜻을 담고 있는 기호와 그 의미는?|{}, 자료의 반복|
|자료 사전에서 사용되는 표기 기호로 주석 이라는 뜻을 담고 있는 기호와 그 의미는?|* *, 자료의 설명|
|자료 사전에서 사용되는 표기 기호로 생략 가능한 자료 라는 뜻을 담고 있는 기호와 그 의미는?|(), 자료의 생략|
|요구사항을 자동으로 분석하고, 요구사항 분석 명세서를 기술하도록 개발된 도구|요구사항 분석용 CASE|
|요구사항 분석용 CASE의 종류중 하나로 시스템 정의, 소프트웨어 요구사항 분석, 시스템/소프트웨어 설계를 위한 도구이다. SoftTech사에서 개발했다.|SADT|
|시스템 실행 과정인 입력, 처리, 출력의 기능을 표현한 것이고, 하향식 소프트웨어 개발을 위한 문서화 도구이다. 기호, 도표등을 사용하므로 보기 쉽다.|HIPO|
|시스템 분석, 설계, 구현 등 시스템 개발 과정에서 고객 또는 개발자 상호 간의 의사소통이 이루어지도록 표준화한 대표적인 객체지향 모델링 언어|UML|
|UML의 구성요소 3가지|사물, 관계, 다이어그램(사관다)|
|다이어그램 안에서 관계가 형성될 수 있는 대상들|사물|
|사물의 종류 4가지|구조 사물, 행동 사물, 그룹 사물, 주해 사물|
|UML의 사물의 종류 중 시스템의 개념적, 물리적 요소를 표현하는 것|구조 사물|
|UML의 사물의 종류 중 시간과 공간에 따른 요소들의 행위를 표현하는 것|행동 사물|
|UML의 사물의 종류 중 요소들을 그룹으로 묶어서 표현 하는 것|그룹 사물|
|UML의 사물의 종류 중 부가적인 설명이나 제약조건 등을 표현하는 것|주해 사물|
|사물과 사물 사이의 연관성을 표현하는 것|관계|
|UML의 관계의 종류 6가지|연관, 집합, 포함, 일반화, 의존, 실체화 관계|
|2개 이상의 사물이 서로 관련되어 있는 관계, 사물 사이를 실선으로 연결하여 표현한다.|연관 관계|
|하나의 사물이 다른 사물에 포함되어 있는 관계, 부분에서 전체로 속이 빈 마름모 실선을 이용하여 연결한다.|집합 관계|
|포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계, 부분에서 전체로 속이 꽉찬 마름모 실선을 이용하여 연결한다.|포함 관계|
|하나의 사물이 다른 사물에 비해 더 일반적이거나 구체적인 관계|일반화 관계|
|필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계|의존 관계|
|사물이 할 수 있거나 해야하는 기능으로, 서로를 그룹화 할 수 있는 관계|실체화 관계|
|사물과 관계를 도형으로 표현한 것|다이어그램|
|클래스와 클래스가 가지는 속성, 클래스 사이의 관계를 표현하는 것, 정적모델링에 속한다.|클래스 다이어그램|
|클래스에 속한 사물들, 인스턴스를 특정 시점의 객체와 객체 사이의 관계로 표현, 럼바우 객체지향 분석 기법에서 객체 모델링에 활용|객체 다이어그램|
|실제 구현 모듈인 컴포넌트 간의 관계나 컴포넌트 간의 인터페이스를 표현|컴포넌트 다이어그램|
|결과물, 프로세스, 컴포넌트 등 물리적 요소들의 위치를 표현|배치 다이어그램|
|클래스나 컴포넌트가 복합 구조를 갖는 경우 그 내부 구조를 표현|복합체 구조 다이어그램|
|유스케이스나 클래스 등의 모델 요소들을 그룹화한 패키지들의 관계를 표현|패키지 다이어그램|
|구조적 다이어그램의 종류 6가지|클래스, 객체, 컴포넌트, 배치, 복합체 구조, 패키지 다이어그램(클객컴배복패)|
|사용자의 요구를 분석하는 것으로, 기능 모델링 작업에 사용, 사용자와 사용 사례로 구성,개발될 시스템을 이용해 수행할 수 있는 기능을 사용자의 관점에서 표현|유스케이스 다이어그램|
|상호 작용하는 시스템이나 객체들이 주고받는 메시지를 표현|시퀀스 다이어그램|
|동작에 참여하는 객체들이 주고받는 메시지와 객체들 간의 연관 관계를 표현|커뮤니케이션 다이어그램|
|하나의 객체가 자신이 속한 클래스의 상태 변화 혹은 다른 객체와의 상호 작용에 따라 상태가 어떻게 변화하는지 표현, 럼바우 객체지향에서 동적 모델링 활용|커뮤니케이션 다이어그램|
|시스템이 어떤 기능을 수행하는지 객체의 처리 로직이나 조건에 따른 처리의 흐름을 순서에 따라 표현|활동 다이어그램|
|상호작용 다이어그램 간의 제어 흐름을 표현|상호작용 다이어그램|
|객체 상태 변화와 시간 제약을 명시적으로 표현|타이밍 다이어그램|
|행위 다이어그램의 종류 7가지|유스케이스, 시퀀스, 커뮤니케이션, 상태, 활동, 상호작용,
타이밍 다이어그램(유시커상활상타)|
|UML에서 표현하는 기본 기능 외에 추가적인 기능을 표현하는 것, 그리고 그 표현 형태|스테레오 타입|
|개발될 시스템이 갖춰야 할 기능을 사용자와 공유하기 위해 그림으로 표현하는 것|기능 모델링|
|기능 모델링의 종류 2가지|유스케이스 다이어그램, 액티비티(활동) 다이어그램|
|활동 다이어그램에서 액티비티 수행을 담당하는 주체를 구분하는 선의 명칭|스윔 레인|
|사용자가 요구한 기능을 구현하는데 필요한 자료들의 논리적인 구조를 표현한 것, 객체들을 클래스로 추상화하여 표현한다.|정적 모델링|
|연관 관계에 있는 두 클래스에 추가적으로 표현해야 할 속성이나 오퍼레이션이 있는 경우 생성하는 클래스|연관 클래스|
|시스템의 내부 구성 요소들의 상태 변화 과정과 그 과정에서 발생하는 상호 작용을 표현한 것|동적 모델링|
|동적 모델링의 종류 3가지|시퀀스, 커뮤니케이션, 상태 다이어그램|
|시퀀스 다이어그램의 구성요소 중 하나로 객체가 메모리에 존재하는 기간을 점선을 그어 표시하는 것|생명선|
|시퀀스 다이어그램의 구성요소 중에 하나로 객체가 메시지를 주고받으며 구동되고 있음을 표현하는 것|실행 상자|
|시퀀스 다이어그램의 구성요소 중에 하나로 객체가 상호 작용을 위해 주고 받는 메세지를 표현하는 것|메시지|
|소프트웨어 개발, 유지보수 등에 필요한 수행 방법과 효율적으로 수행하려는 과정에서 필요한 각종 기법 및 도구를 체계적으로 정리하여 표준화 한 것|소프트웨어 개발 방법론|
|소프트웨어 개발 방법론 6가지|구조적, 정보공학, 객체지향, 컴포넌트 기반, 제품 계열, 애자일 방법론|
|사용자 요구사항을 파악하여 문서화하는 처리 중심의 방법론, 1960년대까지 가장 많이 적용되었던 방법론이다.|구조적 방법론|
|구조적 방법론의 개발 절차|타당성 검토->계획->요구사항->설계->구현->시험->유지보수(타계요설구시유)|
|정보 시스템의 개발을 위해 계획, 분석, 설계, 구축에 정형화된 기법들을 통합 및 적용하는 자료 중심의 방법론|정보공학 방법론|
|정보공학 방법론의 개발 절차|정보 전략 계획 수립->업무 영역 분석->업무 시스템 설계->업무 시스템 구축|
|객체들을 조립해서 소프트웨어를 구현하는 방법론|객체지향 방법|
|객체지향 방법론의 구성 요소 3가지|객체, 클래스, 메시지|
|객체지향 방법론의 특징 4가지|캡슐화, 추상화 ,상속성, 다형성|
|객체지향 방법론의 기본 원칙 5가지|단일 책임 원칙(Single responsibility principle) : SRP, 개방 폐쇄 원칙(Open/closed principle) : OCP, 리스코프 치환 원칙(Liskov substitution principle) : LSP, 인터페이스 분리 원칙(Interface segregation principle) : ISP, 의존관계 역전 원칙(Dependency inversion principle) : DIP|
|객체지향 방법론의 개발 절차|요구 분석->설계->구현->테스트 및 검증->인도|
|컴포넌트를 조합하여 새로운 애플리케이션을 만드는 방법론, 컴포넌트의 재사용이 가능하여 시간과 노력을 절감할 수 있다.|컴포넌트 기반 방법론|
|컴포넌트 기반 방법론의 개발 절차|개발 준비->분석->설계->구현->테스트->전개->인도|
|제품에 적용하고 싶은 공통된 기능을 정의하여 개발하는 방법론|제품 계열 방법론|
|이미 개발되어 인정받은 소프트웨어를 다른 소프트웨어 개발이나 유지에 사용하는 것|소프트웨어 재사용|
|소프트웨어 재사용 방법 중 블록을 만들어서 끼워 맞춰 소프트웨어를 완성시키는 방법|합성 중심|
|소프트웨어 재사용 방법 중 추상화 형태로 써진 명세를 구체화하여 프로그램을 만드는 방법|생성 중심|
|기존 시스템을 이용하여 보다 나은 시스템을 구축하고, 새로운 기능을 추가하여 소프트웨어 성능을 향상시키는 것|소프트웨어 재공학|
|소프트웨어 재공학의 이점 4가지|품질 향상, 생산성 증가, 수명 연장, 오류 감소|
|소프트웨어 개발 과정에서 사용되는 과정 전체 또는 일부를 컴퓨터와 전용 소프트웨어 도구를 사용하여 자동화하는 것|CASE|
|과거의 유사한 경험을 바탕으로 전문 지식이 많은 개발자들이 참여한 회의를 통해 비용을 산정하는 방법|하향식 비용 산정 기법|
|하향식 비용 산정 기법의 종류 2가지|전문가 감정 기법, 델파이 기법|
|경험이 많은 두 명 이상의 전문가에게 비용 산정을 의뢰하는 기법|전문가 감정 기법|
|전문가 감정 기법의 주관적인 편견을 보완하기 위해 많은 전문가의 의견을 종합하여 산정하는 기법|델파이 기법|
|세부적인 작업 단위별로 비용을 산정한 후 집계하여 전체 비용을 산정하는 방법|상향식 비용 산정 기법|
|각 기능의 원시 코드 라인 수의 비관치, 낙관치, 기대치를 측정하여 예측치를 구하고 이를 이용하여 비용을 산정하는 기법|LOC 기법|
|예측치 공식|a+4m+b/6, a=낙관치, b=비관치, m=기대치|
|LOC기법의 산정 공식 1) 노력, 2) 개발 비용, 3) 개발 기간, 4) 생산성|1) 노력 : 개발기간 * 투입인원 = LOC/ 1인당 월평균 생산 라인수 2) 개발비용 : 노력 * 단위 비용, 3) 개발 기간 : 노력 / 투입 인원|
|기능을 구현시키는 데 필요한 노력을 생명 주기의 각 단계별로 산정하는 것, LOC 기법을 보강|개발 단계별 인원수 기법|
|수학적 산정 기법의 종류 3가지|COCOMO모형, Putnam모형, FP모형|
|LOC에 의한 비용 산정 기법, 소프트웨어 종류에 따라 다르게 책정되는 비용 산정 방정식에 대입하여 산정, 보헴이 제안하였다.|COCOMO 모형|
|COCOMO의 소프트웨어 개발 유형 3가지|조직형, 반분리형, 내장형|
|COCOMO의 소프트웨어 개발 유형 중에 하나로 기관 내부에서 개발된 중, 소 규모의 소프트웨어이고 5만 라인 이하의 소프트웨어를 개발한다.|조직형|
|COCOMO의 소프트웨어 개발 유형 중에 하나로 조직형과 내장형의 중간형 소프트웨어이고 30만 라인 이하의 소프트웨어를 개발한다.|반분리형|
|COCOMO의 소프트웨어 개발 유형 중에 하나로 초대형 규모의 소프트웨어이고 30만 라인 이상의 소프트웨어를 개발한다.|내장형|
|소프트웨어 생명 주기의 전 과정 동안에 사용될 노력의 분포를 예상하는 모형이다. 푸트남이 제안하였고, 생명 주기 예측 모형이라고도 한다.|Putnam 모형|
|소프트웨어의 기능을 증대시키는 요인별로 가중치를 부여하여 기능 점수를 구한 후 비용을 산정하는 기법|기능점수(FP)모형|
|Rayleigh-Norden 곡선과 Putnam 예측 모델을 기초로 하여 개발된 자동화 추정 도구|SLIM|
|다양한 프로젝트와 개인별 요소를 수용하도록 FP 모형을 기초로 하여 개발된 자동화 추정 도구|ESTIMACS|
|프로젝트 일정 계획 중 전체 작업의 상호 관계를 표시하는 네트워크|PERT|
|프로젝트 일정 계획 중 작업을 나열하고 작업에 필요한 소요 기간을 예측하는데 사용하는 기법|CPM|
|프로젝트의 작업 일정을 막대 도표를 이용하여 표시하는 프로젝트 일정표|간트 차트|
|소프트웨어 개발 단계에서 수행하는 품질 관리에 사용되는 국제 표준|소프트웨어 개발 표준|
|ISO에서 만든 표준 소프트웨어 생명 주기 프로세스|ISO/IEC 12207|
|기본 생명 주기 프로세스의 종류|획득, 공급, 개발, 운영, 유지보수 프로세스|
|지원 생명 주기 프로세스의 종류|품질 보증, 검증, 확인, 활동 검토, 감사, 문서화, 형상 관리, 문제 해결|
|조직 생명 주기 프로세스의 종류|관리, 기반 구조, 훈련, 개선 프로세스|
|소프트웨어 개발 조직의 업무 능력 및 조직의 성숙도를 평가하는 모델|CMMI|
|CMMI의 소프트웨어 프로세스 성숙도 단계|초기, 관리, 정의, 정량적관리, 최적화|
|소프트웨어의 품질 및 생산성 향상을 위해 소프트웨어 프로세스를 평가 및 개선하는 국제 표준|SPICE|
|SPICE의 구성 5가지|고객-공급자, 공학, 지원, 관리, 조직|
|SPICE의 프로세스 수행 능력 단계|불완전, 수행, 관리, 확립, 예측, 최적화|
|소프트웨어 개발 방법론의 절차, 사용기법 등을 수정 및 보완하는 작업|소프트웨어 개발 방법론 테일러링|
|소프트웨어 개발에 공통적으로 사용되는 구성 요소와 아키텍처를 일반화하여 제공해주는 반제품 형태의 소프트웨어 시스템|소프트웨어 개발 프레임워크|
|자바 플랫폼을 위한 오픈 소스 경량형 애플리케이션 프레임워크이고, 전자정부 표준 프레임워크의 기반 기술로 사용되고 있다.|스프링 프레임워크|
|대한민국의 공공부문 정보화 사업 시 정보시스템의 구축을 지원하기 위해 필요한 기능 및 아키텍처를 제공하는 프레임워크|전자정부 프레임워크|
|Windows의 프로그램의 개발 및 실행 환경을 제공하는 프레임 워크|닷넷 프레임워크|
|소프트웨어 개발 프레임워크의 특성 4가지|모듈화, 재사용성, 확장성, 제어의 역흐름|
|캡슐화를 통해 모듈화를 강화하고 설계 및 구현이 변경에 따른 영향을 최소화함으로써 소프트웨어의 품질을 향상시키는 것|모듈화|
|재사용 가능한 모듈들을 제공함으로써 예산 절감, 생산성 향상, 품질 보증이 가능함|재사용성|
|다형성을 통한 인터페이스 확장이 가능하여 다양한 형태와 기능을 가진 애플리케이션 개발이 가능|확장성|
|개발자가 관리하고 통제해야 하는 객체들의 제어를 프레임워크에 넘김으로써 생산성을 향상시킴|제어의 역흐름|
|공동으로 사용될 데이터를 중복을 배제하여 통합하고, 쉽게 접근하여 처리할 수 있도록 저장장치에 저장하여 항상 사용할 수 있도록 운영하는 운영 데이터|데이터베이스|
|데이터베이스의 정의 4가지|통합된 데이터, 저장된 데이터, 운영 데이터, 공용 데이터|
|자료의 중복을 배제한 데이터의 모임|통합된 데이터|
|컴퓨터가 접근할 수 있는 저장 매체에 저장된 자료|저장된 데이터|
|조직의 고유한 업무를 수행하는 데 반드시 필요한 자료|운영 데이터|
|여러 응용 시스템들이 공동으로 소유하고 유지하는 자료|공용 데이터|
|사용자의 요구에 따라 정보를 생성해주고, 데이터베이스를 관리해주는 소프트웨어, 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성을 해결하기 위해 제안된 소프트웨어|DBMS|
|DBMS의 필수 기능 3가지|정의 기능, 조작 기능, 제어 기능|
|응용 프로그램과 데이터베이스를 독립시킴으로써, 데이터의 논리적 구조를 변경시키더라도 응용 프로그램은 영향을 받지 않음을 의미하는 것|논리적 독립성|
|응용 프로그램과 보조기억장치 같은 물리적 장치를 독립시킴으로써, 디스크를 추가/변경하더라도 응용 프로그램은 영향을 받지 않는 것|물리적 독립성|
|데이터베이스의 구조와 제약조건에 관한 전반적인 명세를 기술한 것|스키마|
|스키마의 종류 3가지|외부 스키마, 개념 스키마, 내부 스키마|
|사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것|외부 스키마|
|데이터베이스의 전체적인 논리적 구조, 모든 응용프로그램이나 사용자들이 필요로 하는 데이터를 종합한 조직 전체의 데이터베이스|개념 스키마|
|물리적 저장장치의 입장에서 본 데이터베이스 구조, 실제로 저장될 레코드의 형식, 저장 데이터 항목의 표현 방법 등을 나타냄|내부 스키마|
|데이터베이스 설계 시 고려사항 6가지|무결성, 일관성, 회복, 보안, 효율성, 데이터베이스 확장|
|삽입, 삭제, 갱신 등의 연산 후에도 데이터베이스에 저장된 데이터가 정해진 제약 조건을 항상 만족해야 함|무결성|
|데이터베이스에 저장된 데이터들 사이나, 특정 질의에 대한 응답이 처음부터 끝까지 변함없이 일정해야 함|일관성|
|시스템에 장애가 발생했을 때 장애 발생 직전의 상태로 복구할 수 있어야 함|회복|
|불법적인 데이터의 노출 또는 변경이나 손실로부터 보호할 수 있어야 함|보안|
|응답시간의 단축, 시스템의 생산성, 저장 공간의 최적화 등이 가능해야 함|효율성|
|데이터베이스 운영에 영향을 주지 않으면서 지속적으로 데이터를 추가할 수 있어야 함|데이터베이스 확장|
|데이터베이스 설계 순서|요구조건 분석->개념적 설계->논리적 설계->물리적 설계->구현|
|데이터베이스를 사용할 사람들로부터 필요한 용도를 파악하는 것|요구 조건 분석|
|현실 세계의 무한성과 계속성을 이해하고, 다른 사람과 통신하기 위하여 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정|개념적 설계|
|현실 세계에서 발생하는 자료를 특정 DBMS가 지원하는 논리적 자료 구조로 변환시키는 과정|논리적 설계|
|논리적 구조로 표현된 데이터를 물리적 저장장치에 저장할 수 있는 물리적 구조의 데이터로 변환하는 과정|물리적 설계|
|논리적 설계와 물리적 설계에서 도출된 데이터베이스 스키마를 파일로 생성하는 과정|데이터베이스 구현|
|현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형|데이터 모델|
|데이터 모델의 구성 요소 3가지|개체, 속성, 관계|
|데이터 모델에 표시할 요소 3가지|구조, 연산, 제약 조건|
|현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정|개념적 데이터 모델|
|개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정|논리적 데이터 모델|
|논리적으로 표현된 개체 타입들 간의 관계로서 데이터 구조 및 정적 성질 표현|구조|
|데이터베이스에 저장된 실제 데이터를 처리하는 작업에 대한 명세로서 데이터베이스를 조작하는 기본 도구|연산|
|데이터베이스에 저장될 수 있는 실제 데이터의 논리적인 제약 조건|제약 조건|
|데이터베이스에 표현하려는 것, 개념이나 정보단위 같은 현실 세계의 대상체|개체|
|데이터베이스를 구성하는 가장 작은 논리적 단위|속성|
|속성의 수|디그리, 차수|
|업무 분석을 통해 정의한 속성, 속성 중 가장 많고 일반적임|기본 속성|
|원래 업무상 존재하지 않고 설계 과정에서 도출해내는 속성|설계 속성|
|다른 속성으로부터 계산이나 변형 등의 영향을 받아 발생하는 속성|파생 속성|
|개체와 개체 사이의 논리적인 연결|관계|
|두 개체 사이의 주 종 관계를 표현한 것|종속 관계|
|두 개체 사이에 2번 이상의 종속 관계가 발생하는 관계|중복 관계|
|개체가 자기 자신과 관계를 갖는 것|재귀 관계|
|개체의 속성이나 구분자를 기준으로 개체의 특성을 분할하는 관계|배타 관계|
|E-R 다이어그램의 기호중 사각형 인것|개체|
|E-R 다이어그램의 기호중 마름모 인 것|관계|
|E-R 다이어그램의 기호 중 타원 인 것|속성|
|E-R 다이어그램의 기호 중 이중타원 인 것|다중값 속성|
|E-R 다이어그램의 기호 중 밑줄 타원 인 것|기본키 속성|
|E-R 다이어그램의 기호 중 복수타원인 것|복합 속성|
|2차원적인 표를 이용해서 데이터 상호 관계를 정의하는 데이터베이스|관계형 데이터베이스|
|릴레이션을 구성하는 각각의 행|튜플|
|하나의 애트리뷰트가 취할 수 있는 같은 타입의 원자값의 집합|도메인|
|릴레이션의 특징 3가지|릴레이션에 포함된 튜플은 모두 상이하다, 튜플 사이에는 순서가 없다, 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변한다.|
|2차원적인 표를 이용해서 데이터 상호 관계를 정의하는 DB 구조|관계형 데이터 모델|
|속성들 중에서 튜플을 유일하게 식별하기 위해 사용되는 속성들의 부분집합|후보키|
|후보키의 속성 2가지|유일성, 최소성|
|하나의 키 값으로 하나의 튜플만을 유일하게 식별할 수 있어야 함|유일성|
|키를 구성하는 속성 하나를 제거하면 유일하게 식별할 수 없도록 꼭 필요한 최소의 속성으로 구성되어야 함.|최소성|
|후보키 중에서 특별히 선정된 주키이다, 중복된 값을 가질 수 없고 한 릴레이션에서 특정 튜플을 유일하게 구별할 수 있는 속성이다.|기본키|
|후보키가 둘 이상일 때 기본키를 제외한 나머지 후보키|대체키|
|한 릴레이션 내에 있는 속성들의 집합으로 구성된 키, 릴레이션을 구성하는 모든 튜플에 대해 유일성은 만족하지만, 최소성은 만족하지 못한다.|슈퍼키|
|다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합|외래키|
|데이터베이스에 저장된 데이터 값과 현실 세계의 실제값이 일치하는 정확성|무결성|
|기본 테이블의 기본키를 구성하는 어떤 속성도 NULL 값이나 중복값을 가질 수 없다는 규정|개체 무결성|
|외래키 값은 NULL이거나 참조 릴레이션의 기본키 값과 동일해야 함. 즉 릴레이션은 참조할 수 없는 외래키 값을 가질 수 없다는 규정|참조 무결성|
|주어진 속성 값이 정의된 도메인에 속한 값이어야 한다는 규정|도메인 무결성|
|속성 값들이 사용자가 정의한 제약조건에 만족되어야 한다는 규정|사용자 정의 무결성|
|릴레이션의 특정 속성 값이 NULL이 될 수 없도록 하는 규정|NULL 무결성|
|릴레이션의 특정 속성에 대해 각 튜플이 갖는 속성값들이 서로 달라야 한다는 규정|고유 무결성|
|하나의 릴레이션에는 적어도 하나의 키가 존재해야 한다는 규정|키 무결성|
|한 릴레이션과 다른 릴레이션의 튜플들 사이의 관계에 대한 적절성 여부를 지정한 규정|관계 무결성|
|원하는 정보와 그 정보를 검색하기 위해서 어떻게 유도하는가를 기술하는 절차적인 언어|관계대수|
|순수 관계 연산자의 종류 4가지|Select, Project, Join, Division|
|일반 집합 연산자의 종류 4가지|합집합, 교집합, 차집합, 교차곱|
|관계 데이터의 연산을 표현하는 방법|관계해석|
|릴레이션에 존재하는 튜플 중에서 선택 조건을 만족하는 튜플의 부분집합을 구하여 새로운 릴레이션을 만드는 연산의 종류와 그 기호|Select|
|주어진 릴레이션에서 속성 리스트에 제시된 속성 값만을 추출하여 새로운 릴레이션을 만드는 연산, 중복이 발생하면 중복이 제거되는 종류와 그 기호|Project|
|공통 속성을 중심으로 두 개의 릴레이션을 하나로 합쳐서 새로운 릴레이션을 만드는 연산의 종류와 그 기호|Join|
|R의 속성이 S의 속성값을 모두 가진 튜플에서 S가 가진 속성을 제외한 속성만을 구하는 연산|Division|
|두 릴레이션에 존재하는 튜플의 합집합을 구하되, 결과로 생성된 릴레이션에서 중복되는 튜플은 제거되는 연산|합집합|
|두 릴레이션에 존재하는 튜플의 교집합을 구하는 연산|교집합|
|두 릴레이션에 존재하는 튜플의 차집합을 구하는 연산|차집합|
|두 릴레이션에 있는 튜플들의 순서쌍을 구하는 연산|교차곱|
|테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이 중복으로 인해 테이블 조작 시 문제가 발생하는 현상|이상|
|테이블에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상|삽입 이상|
|테이블에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상|삭제 이상|
|테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성이 생기는 현상|갱신 이상|
|속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을 때를 의미하는 것, 또 X->Y 일 때 X, Y는?|함수적 종속|
|테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정|정규화|
|테이블 R에 속한 모든 속성의 도메인이 원자 값만으로 되어 있는 정규형, 즉 테이블의 모든 속성값이 원자 값으로만 되어 있는 정규형|제 1정규형|
|기본키가 아닌 모든 속성이 기본키에 대하여 완전 함수적 종속을 만족하는 정규형|제 2정규형|
|기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속을 만족하지 않는 정규형|제 3정규형|
|모든 결정자가 후보키인 정규형|BCNF|
|A ->->B 다중 값 종속이 존재할 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형|제 4정규형|
|모든 조인 종속이 후보키를 통해서만 성립되는 정규형|제 5정규형|
|정규화 과정의 순서를 작성하시오.|제 1정규형->제 2정규형->제 3정규형->BCNF-> 제 4정규형->제 5정규형|
|정규화된 데이터 모델을 의도적으로 통합, 중복, 분리하여 정규화 원칙을 위배하는 행위|반정규화|
|반정규화의 방법 4가지|테이블 통합, 테이블 분리, 중복 테이블 추가, 중복 속성 추가|
|두 개의 테이블에서 발생하는 프로세스가 동일하게 자주 처리되는 경우, 항상 두개의 테이블을 이용하여 조회를 수행하는 경우 수행해야 하는 반정규화|테이블 통합|
|레코드를 기준으로 테이블을 분할하는 것, 레코드별로 사용 빈도의 차이가 큰 경우 사용 빈도에 따라 테이블을 분할함|수평 분할|
|하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할하는 것|수직 분할|
|여러 테이블에서 데이터를 추출해서 사용해야 할 경우, 다른 서버에 저장된 테이블을 이용해야 하는 경우 해야하는 반정규화 방법|중복 테이블의 추가|
|중복 테이블 추가 방법 3가지|집계 테이블의 추가, 진행 테이블의 추가, 특정 부분만을 포함한 테이블 추가|
|집계 데이터를 위한 테이블을 생성하고, 각 원본 테이블에 트리거를 설정하여 사용하는 것|집계 테이블의 추가|
|이력 관리 등의 목적으로 추가하는 테이블|진행 테이블의 추가|
|데이터가 많은 테이블의 특정 부분만을 사용하는 경우 해당 부분만으로 새로운 테이블을 생성|특정 부분만을 포함한 테이블 추가|
|조인이 자주 발생하는 속성인 경우, 접근 경로가 복잡한 속성인 경우, 액세스의 조건으로 자주 사용되는 속성인 경우 해야하는 반정규화 방법|중복 속성 추가|
|시스템 그 자체에 관련이 있는 다양한 객체에 관한 정보를 포함하는 시스템 데이터베이스|시스템 카탈로그|
|시스템 카탈로그에 저장된 정보|메타 데이터|
|데이터 사전에 수록된 데이터에 접근하는 데 필요한 정보를 관리 유지하는 시스템|데이터 디렉터리|
|데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한꺼번에 모두 수행되어야 할 일련의 연산들|트랜잭션|
|트랜잭션의 특성 4가지|원자성, 일관성, 독립성, 영속성|
|트랜잭션의 연산은 데이터베이스에 모두 반영되도록 완료(Commit)되든지 아니면 전혀 반영되지 않도록 복구(Rollback)되어야 하는 트랜잭션의 특성|원자성|
|트랜잭션이 그 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 변환하는 것|일관성|
|둘 이상의 트랜잭션이 동시에 병행 실행되는 경우 어느 하나의 트랜잭션 실행중에 다른 트랜잭션의 연산이 끼어 들 수 없음을 의미하는 것|독립성|
|성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 함|영속성|
|프로세스와 테이블 간에 CRUD 매트릭스를 만들어서 트랜잭션을 분석하는 것|CRUD 분석|
|CRUD 매트릭스를 기반으로 테이블에 발생하는 트랜잭션 양을 분석하여 테이블에 저장되는 데이터의 양을 유추하고 이를 근거로 DB를 최적화 하는 것|트랜잭션 분석|
|데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조|인덱스|
|인덱스의 종류 5가지|트리 기반, 비트맵, 함수 기반, 비트맵 조인, 도메인|
|인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것|트리 기반 인덱스|
|인덱스 컬럼의 데이터를 비트 값인 0 또는 1로 변환하여 인덱스 키로 사용하는 방법|비트맵 인덱스|
|컬럼의 값 대신 컬럼에 특정 함수나 수식을 적용하여 산출된 값을 사용하는 것|함수 기반 인덱스|
|다수의 조인된 객체로 구성된 인덱스|비트맵 조인 인덱스|
|개발자가 필요한 인덱스를 직접 만들어 사용하는 것|도메인 인덱스|
|인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식, 실제 데이터가 순서대로 저장되어 있어 원하는 데이터를 빠르게 찾을 수 있음.|클러스터드 인덱스|
|인덱스의 키 값만 정렬되어 있고 실제 데이터는 정렬되지 않는 방식, 삽입 삭제 발생 시 순서를 유지하기 위해 데이터를 재정렬해야함|논클러스터드 인덱스|
|사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 가상 테이블|뷰|
|동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법|클러스터|
|대용량의 테이블이나 인덱스를 작은 논리적 단위인 파티션으로 나누는 것|파티션|
|파티션의 종류 3가지|범위 분할, 해시 분할, 조합 분할|
|지정한 열의 값을 기준으로 분할 하는 것(일별, 월별, 분기별)|범위 분할|
|해시 함수를 적용한 결과 값에 따라 데이터를 분할하고, 특정 파티션에 데이터가 집중되는 범위 분할의 단점을 보완한 것|해시 분할|
|범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식|조합 분할|
|논리적으로는 하나의 시스템에 속하지만 물리적으로는 네트워크를 통해 연결된 여러 개의 사이트에 분산된 데이터베이스|분산 데이터베이스|
|분산 데이터베이스의 목표 4가지|위치 투명성, 중복 투명성, 병행 투명성, 장애 투명성|
|액세스하려는 데이터베이스의 설계 위치를 알 필요 없이 단지 데이터베이스의 논리적인 명칭만으로 액세스할 수 있음을 의미하는 것|위치 투명성|
|동일 데이터가 여러 곳에 중복되어 있더라도 사용자는 마치 하나의 데이터만 존재하는 것처럼 사용하는 것을 의미하는 것|중복 투명성|
|분산 데이터베이스와 관련된 다수의 트랜잭션들이 동시에 실현되더라도 그 트랜잭션의 결과는 영향을 받지 않는 것을 의미하는 것|병행 투명성|
|트랜잭션, DBMS, 네트워크, 컴퓨터 장애에도 불구하고 트랜잭션을 정확하게 처리하는 것|장애 투명성|
|시스템 오류로 인한 데이터베이스 서비스 중단이나 물리적 손상 발생 시 이를 복구하기 위해 동일한 데이터 베이스를 복제하여 관리하는 것|데이터베이스 이중화|
|데이터베이스의 이중화 기법 2가지|Eager, lazy|
|트랜잭션 수행 중 데이터 변경이 발생하면 이중화된 모든 데이터베이스에 즉시 전달하여 변경 내용이 즉시 적용되도록 하는 기법|Eager|
|트랜잭션의 수행이 종료되면 변경 사실을 새로운 트랜잭션에 작성하여 각 데이터베이스에 전달되는 기법|lazy|
|한 DB가 활성 상태로 서비스하고 있으면 다른 DB는 대기하고 있다가 활성 DB에 장애가 발생하면 대기 상태에 있던 DB가 서비스를 대신 수행하는 것|활동-대기 방법|
|두 개의 DB가 서로 다른 서비스를 제공하다가 둘 중 한쪽 DB에 문제가 발생하면 나머지 다른 DB가 서비스를 제공하는 것|활동-활동 방법|
|두 대 이상의 서버를 하나의 서버처럼 운영하는 기술|클러스터링|
|클러스터링의 종류 2가지|고가용성, 병렬 처리 클러스터링|
|하나의 서버에 장애가 발생하면 다른 서버가 받아 처리하여 서비스 중단을 방지하는 방식|고가용성 클러스터링|
|전체 처리율을 높이기 위해 하나의 작업을 여러개의 서버에서 분산하여 처리하는 방식|병렬 처리 클러스터링|
|비상사태 또는 업무 중단 시점으로부터 복구되어 가동될때까지의 소요 시간|RTO|
|비상사태 또는 업무 중단 시점으로부터 데이터를 복구할 수 있는 기준점|RPO|
|데이터를 보낼 때 송신자가 지정한 수진자 이외에는 그 내용을 알 수 없도록 평문을 암호문으로 변환하는 것|암호화|
|데이터가 저장된 객체와 이를 사용하려는 주체 사이의 정보의 흐름을 제한하는 것|접근통제|
|접근통제의 3요소|접근통제 정책, 접근통제 매커니즘, 접근통제 보안모델|
|데이터에 접근하는 사용자의 신원에 따라 접근 권한을 부여하는 방식, 데이터 소유자가 접근통제 권한을 지정하고 제어함|임의 접근통제|
|주체와 객체의 등급을 비교하여 접근 권한을 부여하는 방식, 시스템이 접근통제 권한을 지정함|강제 접근통제|
|사용자의 역할에 따라 접근 권한을 부여하는 방식, 중앙관리자가 접근통제 권한을 지정|역할기반 접근통제|
|최소 권한 정책으로, 단일 주체에게 하나의 객체에 대한 허가를 부여함|IBP|
|복수 주체에 하나의 객체에 대한 허가를 부여함|GBP|
|사용자나 객체별로 지정된 기밀 분류에 따른 정책|MLP|
|집단별로 지정된 기밀 허가에 따른 정책|CBP|
|데이터베이스의 처리 내용이나 이용 상황 등 상태 변화를 시간의 흐름에 따라 모두 기록한 파일|로그|
|대용량의 데이터를 저장하기 위해 서버와 저장장치를 연결하는 기술|스토리지|
|서버와 저장장치를 전용 케이블로 직접 연결하는 방식, 저장장치를 직접 연결하므로 속도가 빠르고 설치 및 운영이 쉬운 것|DAS|
|서버와 저장장치를 네트워크를 통해 연결하는 방식, 장소에 구애받지 않고 저장장치에 쉽게 접근할 수 있음.|NAS|
|DAS의 빠른 처리와 NAS의 파일 공유 장점을 혼합한 방식으로, 서버와 저장장치를 연결하는 전용 네트워크를 별도로 구성하는 방식|SAN|
|물리 데이터 모델 품질 기준 6가지|정확성, 완정성, 준거성, 최신성, 일관성, 활용성|
|데이터 모델이 요구사항이나 업무 규칙, 표기법에 따라 정확하게 표현된 것|정확성|
|데이터 모델이 데이터 모델의 구성 요소를 누락 없이 정의하고 요구사항이나 업무 영역을 누락 없이 반영한 것|완전성|
|데이터 모델이 데이터 표준, 표준화 규칙, 법적 요건등을 정확하게 준수한 것|준거성|
|데이터 모델이 최근의 이슈나 현행 시스템을 반영하고 있는 것|최신성|
|데이터 모델이 표현상의 일관성을 유지하고 있는 것|일관성|
|작성된 모델과 설명을 사용자가 충분히 이해할 수 있고, 업무 변화에 따른 데이터 구조의 변경이 최소화 될 수 있는 것|활용성|
|자료를 기억장치의 공간 내에 저장하는 방법과 자료 간의 관계, 처리 방법 등을 연구 분석하는 것|자료구조|
|크기와 형이 동일한 자료들이 순서대로 나열된 자료의 집합, 반복적인 데이터 처리 작업에 적합한 구조|배열|
|연속되는 기억장소에 저장되는 자료구조, 삽입 삭제 시 자료의 이동이 필요함|연속 리스트|
|자료들을 임의의 기억공간에 기억시키되, 노드의 포인터 부분을 이용하여 서로 연결시킨 자료 구조, 접근 속도가 느리고 기억 공간의 효율이 좋지 않다.|연결 리스트|
|리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료구조, 후입선출 방식|스택|
|리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지는 자료구조|큐|
|정점과 간선의 두 집합으로 이루어지는 자료 구조|그래프|
|방향 그래프의 최대 간선 수 공식|n(n-1)|
|무방향 그래프의 최대 간선 수 공식|n(n-1)/2|
|정점과 선분을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태|트리|
|트리의 기본 요소로서 자료 항목과 다른 항목에 대한 가지를 합친 것|노드|
|트리의 맨 위에 있는 노드|루트 노드|
|각 노드에서 뻗어나온 가지의 수|디그리|
|자식이 하나도 없는 노드|리프 노드 = 단말 노드|
|자식이 하나라도 있는 노드|비단말 노드|
|임의의 노드에서 루트 노드에 이르는 경로상에 있는 노드들|조상 노드|
|어떤 노드에 연결된 다음 레벨의 노드들|자식 노드|
|어떤 노드에 연결된 이전 레벨의 노드들|부모 노드|
|동일한 부모를 갖는 노드들|형제 노드|
|Tree에서 노드가 가질 수 있는 최대의 레벨|깊이|
|여러 개의 트리가 모여 있는 것|숲|
|노드들의 디그리 중에서 가장 많은 수|트리의 디그리|
|차수가 2 이하인 노드들로 구성된 트리|이진 트리|
|트리의 운행법 3가지|Preorder, Inorder, Postorder|
|정렬 방식 8가지|삽입, 선택, 버블, 쉘, 퀵, 힙, 기수, 합병정렬|
|이미 순서화된 파일에 새로운 하나의 레코드를 순서에 맞게 삽입시켜 정렬하는 방식|삽입 정렬|
|n개의 레코드 중에서 최소값을 찾아 첫 번째 레코드 위치에 놓고, 나머지 n-1개 중에서 다시 최소값을 찾아 두 번째 레코드 위치에 놓는 방식|선택 정령|
|인접한 두개의 레코드 키 값을 비교하여 그 크기에 따라 레코드 위치를 서로 교환하는 정렬 방식|버블 정렬|
|매개변수의 값으로 서브파일을 구성하고, 각 서브파일을 삽입정렬 방식으로 순서 배열하는 정렬 방식|쉘 정렬|
|키를 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽 서브 파일에 분해시키는 과정을 반복하는 정렬 방식|퀵 정렬|
|전이진 트리를 이용한 정렬 방식|힙 정렬|
|이미 정렬되어 있는 두개의 파일을 한 개의 파일로 합병하는 정렬 방식|합병 정렬|
|큐를 이용하여 자릿수 별로 정렬하는 방식|기수 정렬|
|시간 복잡도가 O(n^2)인 정렬 방식|삽입, 선택, 버블, 쉘|
|시간 복잡도가 O(nlogn)인 정렬 방식|퀵, 힙, 합병|
|송 수신 모듈과 중계 모듈 간의 연계를 구현하는 것|통합 구현|
|중간 매개체 없이 송 수신 시스템이 직접 연계하는 방식|직접 연계 방식|
|송 수신 시스템 사이에 중간 매개체를 두어 연계하는 방식|간접 연계 방식|
|데이터를 전송 형식에 맞게 변환하고 송수신을 수행하는 등 송수신과 관련된 모든 처리를 수행하는 서버|연계 서버|
|특수한 목적을 갖는 마크업 언어를 만드는 데 사용되는 다목적 마크업 언어, 웹 브라우저 간 HTML 문법이 호환되지 않는 문제와 SGML의 복잡함을 해결|XML|
|컴퓨터 네트워크 상에서 HTTP/HTTPS, SMTP 등을 이용하여 XML을 교환하기 위한 통신 규약|SOAP|
|웹 서비스와 관련된 서식이나 프로토콜 등을 표준적인 방법으로 기술하고 게시하기 위한 언어, XML로 작성되며, UDDI의 기초|WSDL|
|클라이언트로부터 직접 요청을 받아 처리하고 저용량의 정적 파일을 제공하는 서버|웹 서버|
|동적 서비스를 제공하거나, 웹 서버와 데이터베이스 서버 또는 웹 서버와 파일 서버 사이에서 인터페이스 역할을 수행하는 서버|웹 애플리케이션 서버(WAS)|
|데이터베이스와 이를 관리하는 DBMS를 운영하는 서버|데이터베이스 서버|
|데이터베이스에 저장하기에는 비효율적이거나, 서비스 제공을 목적으로 유지하는 파일들을 저장하는 서버|파일 서버|
|개발 언어의 선정 기준 5가지|적정성, 효율성, 이식성, 친밀성, 범용성|
|개발 언어의 선정 기준 중 개발하려는 소프트웨어의 목적에 적합해야 함을 의미하는 것|적정성|
|개발 언어의 선정 기준 중 코드의 작성 및 구현이 효율적이어야 함을 의미하는 것|효율성|
|개발 언어의 선정 기준 중 다양한 시스템 및 환경에 적용이 가능해야 함을 의미하는 것|이식성|
|개발 언어의 선정 기준 중 개발 언어에 대한 개발자들의 이해도와 활용도가 높아야 함을 의미하는 것|친밀성|
|개발 언어의 선정 기준 중 다른 개발 사례가 존재하고 여러 분야에서 활용되고 있어야 함을 의미하는 것|범용성|
|소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체이다.|소프트웨어 아키텍처|
|소프트웨어의 성능 향상, 시스템의 수정 및 재사용, 유지 관리 등이 용이하도록 시스템의 기능들을 모듈 단위로 나누는 것|모듈화|
|전체적이고 포괄적인 개념을 설계한 후 차레로 세분화하여 구체화시켜 나가는 것|추상화|
|추상화의 유형 3가지|과정 추상화, 데이터 추상화, 제어 추상화|
|자세한 수행 과정을 정의하지 않고, 전반적인 흐름만 파악할 수 있게 설계하는 방법|과정 추상화|
|데이터의 세부적인 속성이나 용도를 정의하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체하는 방법|데이터 추상화|
|이벤트 발생의 정확한 절차나 방법을 정의하지 않고, 대표할 수 있는 표현으로 대체하는 방법|제어 추상화|
|상위의 중요 개념으로부터 하위의 개념으로 구체화시키는 분할 기법|단계적 분해|
|모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법|정보 은닉|
|품질 평가 요소의 종류|시스템 측면, 비즈니스 측면, 아키텍처 측면|
|시스템 측면에서의 평가 요소|성능, 보안, 가용성, 기능성, 사용성, 변경 용이성, 확장성|
|비즈니스 측면에서의 평가 요소|시장 적시성, 비용과 혜택, 예상 시스템 수명, 목표 시장, 공개일정|
|아키텍처 측면에서의 평가 요소|개념적 무결성, 정확성, 완결성, 구축 가능성, 변경성, 시험성|
|컴포넌트를 설계할 때 클래스에 대한 여러 가정을 공유 할 수 있도록 명세한 것|협약에 의한 설계|
|아키텍처를 설계할 때 참조할 수 있는 전형적인 해결방식 또는 예제|아키텍처 패턴|
|시스템을 계층으로 구분하여 구성하는 고전적인 방법의 패턴|레이어 패턴|
|하나의 서버 컴포넌트와 다수의 클라이언트 컴포넌트로 구성되는 패턴|클라이언트-서버 패턴|
|데이터 스트림 절차의 각 단계를 필터로 캡슐화하여 파이프를 통해 전송하는 패턴|파이프-필터 패턴|
|서브시스템을 모델, 뷰, 컨트롤러로 구조화하는 패턴|MVC 패턴|
|슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식으로 작업을 수행하는 패턴|마스터-슬레이브 패턴|
|각 요소들을 객체로 만든 후 객체들을 조립해서 소프트웨어를 개발하는 기법|객체지향|
|객체지향의 구성 요소 3가지|객체, 클래스, 메시지|
|객체지향의 특징 4가지|캡슐화, 상속, 다형성, 연관성|
|데이터와 이를 처리하기 위한 함수를 묶어 놓은 소프트웨어 모듈|객체|
|공통된 속성과 연산을 갖는 객체의 집합|클래스|
|객체들 간의 상호작용에 사용되는 수단으로, 객체의 동작이나 연산을 일으키는 외부의 요구 사항|메시지|
|외부에서의 접근을 제한하기 위해 인터페이스를 제외한 세부내용을 은닉하는 것|캡슐화|
|상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것|상속|
|하나의 메시지에 대해 각각의 객체가 가지고 있는 고유한 방법으로 응답할 수 있는 능력|다형성|
|두 개 이상의 객체들이 상호 참조하는 관계|연관성|
|연관성의 종류 5가지|연관화, 분류화, 집단화, 일반화, 특수화|
|사용자의 요구사항과 관련된 객체, 속성, 연산, 관계 등을 정의하여 모델링하는 작업|객체지향 분석|
|E-R 다이어그램을 사용하여 객체의 행위를 모델링하는 방법|Coad와 Yourdon 방법|
|모든 소프트웨어 구성요소를 그래픽 표기법을 이용하여 모델링하는 기법, 객체 모델링 기법이라고도 한다,|럼바우의 분석 기법|
|럼바우 분석 활동 순서|객체 모델링->동적 모델링->기능 모델링|
|정보 모델링이라고도 하며, 시스템에서 요구되는 객체를 찾아내어 속성과 연산 식별 및 객체들 간의 관계를 규정하여 객체 다이어그램으로 표시하는 것|객체 모델링|
|상태 다이어그램을 이용하여 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호 작용, 동작 순서 등의 동적인 행위를 표현하는 모델링|동적 모델링|
|자료 흐름도를 이용하여 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현한 모델링|기능 모델링|
|변경이나 확장에 유연한 시스템을 설계하기 위해 지켜져야 할 원칙|객체지향 설계 원칙|
|객체는 단 하나의 책임만 가져야 한다는 원칙|단일 책임 원칙|
|기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 설계해야 한다는 원칙|개방-폐쇄 원칙|
|자식 클래스는 최소한 부모 클래스의 기능은 수행할 수 있어야 한다는 원칙|리스코프 치환 원칙|
|자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받지 않아야 한다는 원칙|인터페이스 분리 원칙|
|의존 관계 성립 시 추상성이 높은 클래스와 의존 관계를 맺어야 한다는 원칙|의존 역전 원칙|
|모듈화를 통해 분리된 시스템의 각 기능|모듈|
|모듈 간에 상호 의존하는 정도 또는 두 모듈 사이의 연관 관계|결합도|
|결합도의 종류 6가지|내용, 공통, 외부, 제어, 스탬프, 자료 결합도|
|한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도|내용 결합도|
|공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도, 파라미터가 아닌 모듈 밖에 선언된 전역 변수를 사용하여 전역 변수를 갱신하는 결합도|공통 결합도|
|어떤 모듈에서 선언한 데이터를 외부의 다른 모듈에서 참조할 때의 결합도|외부 결합도|
|어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 제어 신호나 제어 요소를 전달하는 결합도|제어 결합도|
|모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도|스탬프 결합도|
|모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도|자료 결합도|
|모듈의 내부 요소들이 서로 관련되어 있는 정도|응집도|
|모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우의 응집도|기능적 응집도|
|모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우의 응집도|순차적 응집도|
|동일한 입력과 출력을 사용하여 서로 다른 기능을 수행하는 구성 요소들이 모였을 경우의 응집도|교환적 응집도|
|모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도|절차적 응집도|
|특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우의 응집도|시간적 응집도|
|유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 하나의 모듈이 형성되는 경우의 응집도|논리적 응집도|
|모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성된 경우의 응집도|우연적 응집도|
|응집도의 종류 7가지|기능적, 순차적, 교환적, 절차적, 시간적, 논리적, 우연적 응집도|
|어떤 모듈을 제어하는 모듈의 수|팬인|
|어떤 모듈에 의해 제어되는 모듈의 수|팬아웃|
|논리의 기술에 중점을 두고 도형을 이용해 표현하는 방법|N-S 차트|
|한 가지 동작을 수행하는 기능을 모듈로 구현한 것|단위 모듈|
|모듈 간 통신 방식을 구현하기 위해 사용되는 대표적인 프로그래밍 인터페이스 집합|IPC|
|IPC의 대표 메소드 5가지|Shared Memory, Socket, Semaphores, Pipes&named Pipes, Message Queueing|
|공유 가능한 메모리를 구성하여 다수의 프로세스가 통신하는 방식|Shared Memory|
|네트워크 소켓을 이용하여 네트워크를 경유하는 프로세스간에 통신하는 방식|Socket|
|공유 자원에 대한 접근 제어를 통해 통신하는 방식|Semaphores|
|Pipe라고 불리는 선입선출 형태로 구성된 메모리를 여러 프로세스가 공유하여 통신하는 방식|Pipes&named Pipes|
|메시지가 발생하면 이를 전달하는 방식으로 통신하는 방식|Message Queueing|
|소프트웨어가 사용자의 요구사항을 정확하게 준수했는지를 확인하기 위한 테스트 항목에 대한 명세서|테스트 케이스|
|여러 프로그램에서 공통으로 사용할 수 있는 모듈|공통 모듈|
|공통 모듈 명세 기법의 종류 5가지|정확성, 명확성, 완전성, 일관성, 추적성|
|시스템 구현 시 해당 기능이 필요하다는 것을 알 수 있도록 정확히 작성함|정확성|
|해당 기능을 이해할 때 중의적으로 해석되지 않도록 명확하게 작성함|명확성|
|시스템 구현을 위해 필요한 모든 것을 기술함|완전성|
|공통 기능들 간 상호 충돌이 발생하지 않도록 작성함|일관성|
|기능에 대한 요구사항의 출처, 관련 시스템 등의 관계를 파악할 수 있도록 작성함|추적성|
|이미 개발된 기능들을 새로운 시스템이나 기능 개발에 사용하기 적합하도록 최적화하는 작업|재사용|
|재사용 규모에 따른 분류 3가지|함수와 객체, 컴포넌트, 애플리케이션|
|클래스나 메소드 단위의 소스 코드를 재사용함|함수와 객체|
|컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용함|컴포넌트|
|공통된 기능들을 제공하는 애플리케이션을 공유하는 방식으로 재사용함|애플리케이션|
|코드의 주요 기능 5가지|식별, 분류, 배열, 표준화, 간소화|
|데이터 간의 성격에 따라 구분이 가능함|식별 기능|
|특정 기준이나 동일한 유형에 해당하는 데이터를 그룹화 할 수 있음|분류 기능|
|의미를 부여하여 나열할 수 있음|배열 기능|
|다양한 데이터를 기준에 맞추어 표현할 수 있음|표준화 기능|
|복잡한 데이터를 간소화할 수 있음|간소화 기능|
|자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 최초의 자료부터 차례로 일련번호를 부여하는 방법 ex)1, 2, 3, 4|순차 코드|
|코드화 대상 항목 중에서 공통성이 있는 것끼리 블록으로 구분하고, 각 블록 내에서 일련번호를 부여하는 방법 ex) 1001~1100 : 총무부|블록 코드|
|코드화 대상 항목을 0~9까지 10진 분할하고, 각각에 대하여 10진 분할하는 방법을 필요한 만큼 반복하는 방법 ex) 1000 : 공학 1100 : 소프트웨어 공학|10진 코드|
|코드화 대상 항목을 일정 기준에 따라 대분류, 중분류, 소분류 등으로 구분하고 각 그룹 안에서 일련번호를 부여하는 방법 ex)1-01-001 : 본사-총무부-인사계|그룹 분류 코드|
|코드화 대상 항목의 명칭이나 약호와 관계있는 숫자나 문자, 기호를 이용하여 코드를 부여하는 방법 ex) TV-40 : 40인치 TV|연상 코드|
|코드화 대상 항목의 성질, 즉 길이, 넓이, 부피, 지름, 높이 등의 물리적 수치를 그대로 코드에 적용시키는 방법 ex) 120-720-1500 : 두께x폭x길이|표의 숫자 코드|
|필요한 기능을 하나의 코드로 수행하기 어려운 경우 2개 이상의 코드를 조합하여 만드는 방법|합성 코드|
|모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제|디자인 패턴|
|GOF 디자인 패턴의 종류 3가지|생성, 구조, 행위 패턴|
|클래스나 객체의 생성과 참조 과정을 정의하는 패턴|생성 패턴|
|구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관 의존하는 객체들의 그룹으로 생성하여 추상적으로 표현하는 패턴|추상 팩토리|
|작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성하는 패턴|빌더|
|객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴, 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당|팩토리 메소드|
|원본 객체를 복제하는 방법으로 객체를 생성하는 패턴|프로토타입|
|하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수 없음, 인스턴스가 하나 뿐임을 보장하는 패턴|싱글톤|
|구조가 복잡한 시스템을 개발하기 쉽도록 클래스나 객체들을 조합하여 더 큰 구조로 만드는 패턴|구조 패턴|
|호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용 할 수 있도록 변환해주는 패턴|어댑터|
|구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴|브리지|
|여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴|컴포지트|
|객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴|데코레이터|
|복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴|퍼싸드|
|인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한한 공유해서 사용함으로써 메모리를 절약하는 패턴|플라이웨이트|
|접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴|프록시|
|클래스나 객체들이 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴|행위 패턴|
|요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어가는 형태의 패턴|책임 연쇄|
|요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남기는 패턴|커맨드|
|언어에 문법 표현을 정의하는 패턴|인터프리터|
|자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴|반복자|
|수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴|중재자|
|특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴|메멘토|
|한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴, 일대다의 의존성을 정의함|옵저버|
|객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴|상태|
|동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴|전략|
|상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴|템플릿 메소드|
|실제 로직을 가지고 있는 객체가 로직을 적용할 객체를 방문하면서 실행하는 패턴|방문자|
|소스 코드 파일들을 컴퓨터에서 실행할 수 있는 제품 소프트웨어로 변환하는 과정 또는 결과물|빌드|
|아파치 소프트웨어 재단에서 개발하였고 자바 프로젝트의 공식적인 빌드 도구|Ant|
|아파치 소프트웨어 재단에서 Ant의 대안으로 개발하였고 의존성을 설정하여 라이브러리를 관리함|Maven|
|Ant와 Maven을 보완하여 개발하였고, 안드로이드 스튜디오의 공식 빌드 도구|Gradle|
|개발에 참여하는 사람들이 서로 다른 작업 환경에서 원활히 프로젝트를 수행 할 수 있도록 도와주는 도구|협업 도구|
|JAVA를 기반으로 만든 서버 개발 프레임워크|Spring|
|JavaScript를 기반으로 만든 서버 개발 프레임워크|Node.js|
|Python을 기반으로 만든 서버 개발 프레임워크|Django|
|PHP를 기반으로 만든 서버 개발 프레임워크|Codeigniter|
|Ruby를 기반으로 만든 서버 개발 프레임워크|Ruby on Rails|
|데이터 교환을 위해 사용할 객체를 만드는 과정, 송 수신할 데이터의 자료형에 맞는 변수 및 객체를 생성|DTO/VO 구현|
|데이터의 삽입, 변경, 삭제등의 작업을 수행할 SQL문을 생성하는 과정|SQL 구현|
|데이터베이스에 접근하고, SQL을 활용하여 데이터를 실제로 조작하는 코드를 구현하는 과정|DAO 구현|
|사용자의 요청에 응답하기 위한 로직을 구현하는 과정|Service 구현|
|사용자의 요청에 적절한 서비스를 호출하여, 그 결과를 사용자에게 반환하는 코드를 구현하는 과정|Controller 구현|
|응용 프로그램 개발 시 운영체제나 프로그래밍 언어 등에 있는 라이브러리를 이용할 수 있도록 규칙 등을 정의해 놓은 인터페이스|API|
|사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하도록 만든 프로그램|배치 프로그램|
|배치 프로그램의 필수 요소 5가지|대용량 데이터, 자동화, 견고성, 안정성, 성능|
|대량의 데이터를 가져오거나, 전달하거나, 계산하는 등의 처리가 가능해야 함을 의미하는 것|대용량 데이터|
|심각한 오류가 발생하는 상황을 제외하고는 사용자의 개입 없이 수행되어야 한다는 것을 의미하는 것|자동화|
|잘못된 데이터나 데이터 중복 등의 상황으로 중단되는 일 없이 수행되어야 함을 의미하는 것|견고성|
|오류가 발생하면 오류의 발생 위치, 시간 등을 추적할 수 있어야 한다는 것|안정성|
|다른 응용 프로그램의 수행을 방해하지 않아야하고, 지정된 시간 내에 처리가 완료되어야 한다는 것|성능|
|일괄 처리 작업이 설정된 주기에 맞춰 자동으로 수행되도록 지원해주는 도구|배치 스케줄러|
|Spring Source 사와 Accenture 사가 2007년 공동 개발한 오픈 소스 프레임워크|스프링 배치|
|스프링 프레임워크로 개발되는 응용 프로그램들의 일괄 처리를 위한 다양한 기능을 제공하는 오픈 소스 라이브러리|Quartz|
|리눅스의 기본 스케줄러 도구|cron|
|기업에서 일반적으로 사용하는 여러 기능을 통합하여 제공하는 소프트웨어|패키지 소프트웨어|
|요구사항 명세서의 오류 확인 및 표준 준수 여부 등의 결함 여부를 검토 담당자들이 수작업으로 분석하는 방법|요구사항 검토|
|요구사항 명세서 작성자가 명세서 내용을 직접 설명하고 동료들이 이를 들으면서 결함을 발견하는 형태의 검토 방법|동료 검토|
|검토 회의 전에 요구사항 명세서를 미리 배포하여 사전 검토한 후에 짧은 검토 회의를 통해 결함을 발견하는 형태의 검토 방법|워크스루|
|요구사항 명세서 작성자를 제외한 다른 검토 전문가들이 요구사항 명세서를 확인하면서 결함을 발견하는 형태의 검토 방법|인스펙션|
|사용자의 요구사항을 정확히 파악하기 위해 실제 개발될 소프트웨어에 대한 견본품을 만들어 최종 결과물을 예측하는 방법|프로토타이핑|
|인터페이스 요구사항 검증의 주요 항목 7가지|완전성, 일관성, 명확성, 기능성, 검증 가능성, 추적 가능성, 변경 용이성|
|사용자의 모든 요구사항이 누락되지 않고 완전하게 반영돼있는가에 대한 항목|완전성|
|요구사항이 모순되거나 충돌되는 점 없이 일관성을 유지하고 있는가에 대한 항목|일관성|
|모든 참여자가 요구사항을 명확히 이해할 수 있는가에 대한 항목|명확성|
|요구사항이 어떻게 보다 무엇을 에 중점을 두고 있는가에 대한 항목|기능성|
|요구사항이 사용자의 요구를 모두 만족하고, 개발된 소프트웨어가 사용자의 요구 내용과 일치하는지를 검증할 수 있는가에 대한 항목|검증 가능성|
|요구사항 명세서와 설계서를 추적할 수 있는가에 대한 항목|추적 가능성|
|요구사항 명세서의 변경이 쉽도록 작성되었는가에 대한 항목|변경 용이성|
|인터페이스 통신 유형 중 하나로 시스템에서 거래를 요청만 하고 응답이 없는 방식|단방향|
|인터페이스 통신 유형 중 하나로 시스템에서 거래를 요청하고 응답이 올 때까지 대기하는 방식|동기|
|인터페이스 통신 유형 중 하나로 시스템에서 거래를 요청하고 다른 작업을 수행하다 응답이 오면 처리하는 방식|비동기|
|운영체제와 응용 프로그램, 서버와 클라이언트 사이에서 다양한 서비스를 제공하는 소프트웨어|미들웨어|
|클라이언트에서 원격의 데이터베이스와 연결하는 미들웨어|DB|
|원격 프로시저를 마치 로컬 프로시저처럼 호출하는 미들웨어|RPC|
|비동기형 메시지를 전달하는 미들웨어|MOM|
|온라인 트랜잭션 업무에서 트랜잭션을 처리 및 감시하는 미들웨어|TP-Monitor|
|코바 표준 스펙을 구현한 객체 지향 미들웨어|ORB|
|사용자의 요구에 따라 변하는 동적인 콘텐츠를 처리하기 위한 미들웨어|WAS|
|기업 내 각종 애플리케이션 및 플랫폼 간의 정보 전달, 연계, 통합 등 상호 연동이 가능하게 해주는 솔루션|EAI|
|가장 기본적인 애플리케이션 통합 방식, 애플리케이션을 1:1로 연결하고 변경 및 재사용이 어려움|Point-to-Point|
|단일 접점인 허브 시스템을 통해 데이터를 전송하는 중앙 집중형 방식, 확장 및 유지 보수가 용이함|Hub & Spoke|
